### 数组

一维数组

数组是含有多个数值的数据结构，每个数据值具有相同的数据类型，这些数值成为元素。

声明数值，需要说明数组元素的**类型**和**数量**
```
int a[10];
```

数组下标或索引，指示元素的位置

数组初始化

通过一个常量表达式，大括号扩起来

```
int a[3]={1,2,3};
```
如果初始化大括号的数据少，则剩下的位置赋值0。不允许完全为空，也不允许超出长度。

或者不指定长度，只指定初始化大括号值，让编译器来确定数组大小
```
int a[]={1,2,3}
```

### 指针

程序运行操纵的是内存，而内存中存的都是数据，我们操纵数据的同时，也可以获取到该数据在内存中的地址，这就是指针。

使用指针变量来存储地址，指针就是地址

```
int *p; //指向int型对象的指针变量
```

取地址运算符

为了找到变量的地址，可以使用``&``取地址运算符，如果x是变量，&x就是x的地址；
而为了获取指针指向对象，可以使用``*``间接寻址运算符，如果p是指针，*p就是p指向的对象

const关键字用来保护参数不被改变，具体取决与const所处的位置

```
const int *p; //保护 *p，也就是保护p指向的对象不被改变

int * const p; //是保护p，也就是p指针不能被改变指向别的
```

函数也可以返回指针

```
int *f (int * a,int * b){
    return a;
}

```
永远不要返回自动局部变量的指针，因为函数退出，局部变量就不存在来，指向变量的指针是无效的
```
int * f(void){
    int i;
    return &i;
}
这时候f返回后的指针，不知道指向哪
```

### 指针和数组

只有当指针指向数组的时候，指针才可以进行算术运算
```
int a[10];
int *p = a;

p+2 代表a向后移动2个元素
p-2代表a向前移动2个元素

p-q当且仅当p和q在同一个数组上时，代表两个元素相差的位置
```

实际上，指针是地址，当在指针上加一个整数或减去一个整数，获取指针之间的运算，都是地址的运算，只不过只有在数组上才有意义

比如
```
int a[10];
int * p =a;
此时p指向a第一个元素的地址，也就是a起始地址，当p+2的时候，地址运算是 p + (2 * sizeof(int))，移动的偏移量是2 * 指针所指向元素类型的字节数，
对于数组
0           1               2
sizeof(int) | sizeof(int) | sizeof(int) |

当p+2 也就是p地址移动到 p+ 2 * (sizeof(int))时，也就是到了1的结尾2的开始地址，也就是a[2]



```

指针和多维数组

C语言始终是按行来存储多维数组

```
对于int a[3][3]，3行3列的二维数组，内存存储的形式是：

第0行            |第1行            | 第2行            |

int | int | int |int | int | int  | int | int | int |


那么我们平时获取数组元素是
for(row = 0; row < 行数 ; row ++){

    for(col = 0; col < 列数; col++){
        a[row][col];//根据行列数来获取元素
    }
}

当我们知道多维数组实际上也是按照一维数组，只不过每个元素也是个数组
那么可以将指针指向第一个元素，然后向前移动来遍历所有元素

int *p;
for(p = &a[0][0]; p <= &a[row-1][col-1]; p++){
    *p;获取元素
}


但最好不要这么做

这里面还有一点就是，当一维数组时 a[0]表示第一个元素，但多维数组是a[0]表示第一行的地址，当a + 1时，移动的是一行的地址字节数

int a[2][2];
int **p =a;这时候应该用指针的指针来指向数组

int *p =a[0];第一行的地址，一维数组用指向的指针

p + 1地址的移动是 p + 1 * (列数 * sizeof(int))
```

### 动态存储分配 （dynamic storage allocation）

程序执行期间分配内存单元，根据动态存储分配可以设计扩大或缩小

``<stdlib.h>``库：

+ malloc -- 分配内存块，但不对内存卡初始化
+ calloc -- 分配内存块，对内存初始化，会比malloc慢
+ realloc -- 调整先前分配的内存块

因为上述函数不知道准备在内存块存什么类型的数据，所以都是返回void * 指针，代表通用指针，可以被转成其他类型的指针

如果没有分配出内存，会返回NULL空指针，

```
p = malloc(100);
if (p == NULL){

    //分配失败，处理
}

void * malloc(size_t size);分配size字节的内存块，并返回指针，size_t类型是C定义的C符号整数类型

通常需要sizeof配合，得到字节数
int *p = malloc(N * sizeof(int));

void *calloc(size_t nmemb ,size_t size);
为nmemb个元素的数组分配内存，每个元素占用size字节的大小，并初始化内存0

void *realloc(void *ptr, size_t size);调整内存大小，ptr必须指向先前通过malloc、calloc或realloc分配的内存地址，size表示新的内存尺寸，如果比之前大会扩展；
如果不能扩展，就返回空指针NULL，但之前内存的数据不会动

malloc和其他分配函数的内存都是来自 **堆（heap）**的内存存储池，如果不释放，会导致堆内存耗尽，通过
free(p);来释放内存
同时避免悬空指针，也就是p内存被释放了，但后面又用了，通常用 p=NULL 来进行编译器校验

```

指针就是个数，也占用内存，所以指针也有内存地址，也就有指针的指针，例如char **p;

函数也是二进制字节流，在内存中也是数，函数也有地址，所以也有函数指针，也就是指向函数的指针

void (*f) (int);表示函数参数为int，返回void的函数指针f

可以(*p)(1)调用f，也可以f(1)调用

```

int max(int x,int y){}

 //参数为函数指针的函数
int min(int x, int (*p)(int,int)){
    p(1,x);p可以作为函数直接调用

}

int main(){

    int (*p) (int,int) = max; 可以&max，也可以不用
    p(1,2);函数指针直接调用

    min(1,p);
}

```