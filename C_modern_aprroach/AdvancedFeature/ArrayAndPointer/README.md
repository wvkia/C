### 数组

一维数组

数组是含有多个数值的数据结构，每个数据值具有相同的数据类型，这些数值成为元素。

声明数值，需要说明数组元素的**类型**和**数量**
```
int a[10];
```

数组下标或索引，指示元素的位置

数组初始化

通过一个常量表达式，大括号扩起来

```
int a[3]={1,2,3};
```
如果初始化大括号的数据少，则剩下的位置赋值0。不允许完全为空，也不允许超出长度。

或者不指定长度，只指定初始化大括号值，让编译器来确定数组大小
```
int a[]={1,2,3}
```

### 指针

程序运行操纵的是内存，而内存中存的都是数据，我们操纵数据的同时，也可以获取到该数据在内存中的地址，这就是指针。

使用指针变量来存储地址，指针就是地址

```
int *p; //指向int型对象的指针变量
```

取地址运算符

为了找到变量的地址，可以使用``&``取地址运算符，如果x是变量，&x就是x的地址；
而为了获取指针指向对象，可以使用``*``间接寻址运算符，如果p是指针，*p就是p指向的对象

const关键字用来保护参数不被改变，具体取决与const所处的位置

```
const int *p; //保护 *p，也就是保护p指向的对象不被改变

int * const p; //是保护p，也就是p指针不能被改变指向别的
```

函数也可以返回指针

```
int *f (int * a,int * b){
    return a;
}

```
永远不要返回自动局部变量的指针，因为函数退出，局部变量就不存在来，指向变量的指针是无效的
```
int * f(void){
    int i;
    return &i;
}
这时候f返回后的指针，不知道指向哪
```

### 指针和数组

只有当指针指向数组的时候，指针才可以进行算术运算
```
int a[10];
int *p = a;

p+2 代表a向后移动2个元素
p-2代表a向前移动2个元素

p-q当且仅当p和q在同一个数组上时，代表两个元素相差的位置
```

实际上，指针是地址，当在指针上加一个整数或减去一个整数，获取指针之间的运算，都是地址的运算，只不过只有在数组上才有意义

比如
```
int a[10];
int * p =a;
此时p指向a第一个元素的地址，也就是a起始地址，当p+2的时候，地址运算是 p + (2 * sizeof(int))，移动的偏移量是2 * 指针所指向元素类型的字节数，
对于数组
0           1               2
sizeof(int) | sizeof(int) | sizeof(int) |

当p+2 也就是p地址移动到 p+ 2 * (sizeof(int))时，也就是到了1的结尾2的开始地址，也就是a[2]



```

指针和多维数组

C语言始终是按行来存储多维数组

```
对于int a[3][3]，3行3列的二维数组，内存存储的形式是：

第0行            |第1行            | 第2行            |

int | int | int |int | int | int  | int | int | int |


那么我们平时获取数组元素是
for(row = 0; row < 行数 ; row ++){

    for(col = 0; col < 列数; col++){
        a[row][col];//根据行列数来获取元素
    }
}

当我们知道多维数组实际上也是按照一维数组，只不过每个元素也是个数组
那么可以将指针指向第一个元素，然后向前移动来遍历所有元素

int *p;
for(p = &a[0][0]; p <= &a[row-1][col-1]; p++){
    *p;获取元素
}


但最好不要这么做

这里面还有一点就是，当一维数组时 a[0]表示第一个元素，但多维数组是a[0]表示第一行的地址，当a + 1时，移动的是一行的地址字节数

int a[2][2];
int **p =a;这时候应该用指针的指针来指向数组

int *p =a[0];第一行的地址，一维数组用指向的指针

p + 1地址的移动是 p + 1 * (列数 * sizeof(int))
```

